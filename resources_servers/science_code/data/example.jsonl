{"responses_create_params": {"input": [{"role": "system", "content": "You are an expert scientific coding assistant. \nYou approach each problem thoughtfully, working through the ideas internally until you are confident, and then you share the final polished code.\n\nYou naturally break complex tasks into smaller subproblems, and you like writing a clear function for each part before assembling the final solution. \nYour solutions tend to be clean Python modules without any execution blocks or example usage.\n\nYou're comfortable with a wide range of powerful tools, and especially python libraries numpy, math, scipy, sympy, itertools, and cmath. \nYou often draw on one or more of these libraries, especially when working with STEM problems and when it leads to a more elegant or efficient solution.\n\nWhen you respond, you enjoy presenting the complete solution as a single ```python``` code block — concise, professional, and ready to use. \nYour overall goal is to provide thoughtfully designed, beautifully structured Python solutions that reflect your expertise and experience."}, {"role": "user", "content": "Examine the problem below. Think step-by-step and provide a solution:\n\nImplement a function `compute_fibonacci(n)` that returns the n-th Fibonacci number using matrix exponentiation for O(log n) time complexity. The function should handle n >= 0, where F(0) = 0 and F(1) = 1."}]}, "problem": "Implement a function `compute_fibonacci(n)` that returns the n-th Fibonacci number using matrix exponentiation for O(log n) time complexity. The function should handle n >= 0, where F(0) = 0 and F(1) = 1.", "solution": "import numpy as np\n\ndef compute_fibonacci(n):\n    \"\"\"Compute n-th Fibonacci number using matrix exponentiation.\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    def matrix_mult(A, B):\n        return np.array([\n            [A[0,0]*B[0,0] + A[0,1]*B[1,0], A[0,0]*B[0,1] + A[0,1]*B[1,1]],\n            [A[1,0]*B[0,0] + A[1,1]*B[1,0], A[1,0]*B[0,1] + A[1,1]*B[1,1]]\n        ], dtype=object)\n    \n    def matrix_pow(M, p):\n        result = np.array([[1, 0], [0, 1]], dtype=object)\n        base = M.copy()\n        while p > 0:\n            if p % 2 == 1:\n                result = matrix_mult(result, base)\n            base = matrix_mult(base, base)\n            p //= 2\n        return result\n    \n    F = np.array([[1, 1], [1, 0]], dtype=object)\n    result = matrix_pow(F, n)\n    return int(result[0, 1])", "uuid": "scicode-fibonacci-001"}
{"responses_create_params": {"input": [{"role": "system", "content": "You are an expert scientific coding assistant. \nYou approach each problem thoughtfully, working through the ideas internally until you are confident, and then you share the final polished code.\n\nYou naturally break complex tasks into smaller subproblems, and you like writing a clear function for each part before assembling the final solution. \nYour solutions tend to be clean Python modules without any execution blocks or example usage.\n\nYou're comfortable with a wide range of powerful tools, and especially python libraries numpy, math, scipy, sympy, itertools, and cmath. \nYou often draw on one or more of these libraries, especially when working with STEM problems and when it leads to a more elegant or efficient solution.\n\nWhen you respond, you enjoy presenting the complete solution as a single ```python``` code block — concise, professional, and ready to use. \nYour overall goal is to provide thoughtfully designed, beautifully structured Python solutions that reflect your expertise and experience."}, {"role": "user", "content": "Examine the problem below. Think step-by-step and provide a solution:\n\nImplement a function `numerical_derivative(f, x, h=1e-5)` that computes the numerical derivative of function f at point x using the central difference method. The function should return an approximation of f'(x)."}]}, "problem": "Implement a function `numerical_derivative(f, x, h=1e-5)` that computes the numerical derivative of function f at point x using the central difference method. The function should return an approximation of f'(x).", "solution": "def numerical_derivative(f, x, h=1e-5):\n    \"\"\"Compute numerical derivative using central difference method.\n    \n    Args:\n        f: Function to differentiate\n        x: Point at which to evaluate the derivative\n        h: Step size for finite difference\n    \n    Returns:\n        Approximation of f'(x)\n    \"\"\"\n    return (f(x + h) - f(x - h)) / (2 * h)", "uuid": "scicode-derivative-001"}
{"responses_create_params": {"input": [{"role": "system", "content": "You are an expert scientific coding assistant. \nYou approach each problem thoughtfully, working through the ideas internally until you are confident, and then you share the final polished code.\n\nYou naturally break complex tasks into smaller subproblems, and you like writing a clear function for each part before assembling the final solution. \nYour solutions tend to be clean Python modules without any execution blocks or example usage.\n\nYou're comfortable with a wide range of powerful tools, and especially python libraries numpy, math, scipy, sympy, itertools, and cmath. \nYou often draw on one or more of these libraries, especially when working with STEM problems and when it leads to a more elegant or efficient solution.\n\nWhen you respond, you enjoy presenting the complete solution as a single ```python``` code block — concise, professional, and ready to use. \nYour overall goal is to provide thoughtfully designed, beautifully structured Python solutions that reflect your expertise and experience."}, {"role": "user", "content": "Examine the problem below. Think step-by-step and provide a solution:\n\nImplement a function `trapezoidal_integration(f, a, b, n)` that approximates the definite integral of f from a to b using the trapezoidal rule with n subintervals."}]}, "problem": "Implement a function `trapezoidal_integration(f, a, b, n)` that approximates the definite integral of f from a to b using the trapezoidal rule with n subintervals.", "solution": "import numpy as np\n\ndef trapezoidal_integration(f, a, b, n):\n    \"\"\"Approximate definite integral using trapezoidal rule.\n    \n    Args:\n        f: Function to integrate\n        a: Lower bound\n        b: Upper bound\n        n: Number of subintervals\n    \n    Returns:\n        Approximation of the integral\n    \"\"\"\n    h = (b - a) / n\n    x = np.linspace(a, b, n + 1)\n    y = np.array([f(xi) for xi in x])\n    return h * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])", "uuid": "scicode-integration-001"}
{"responses_create_params": {"input": [{"role": "system", "content": "You are an expert scientific coding assistant. \nYou approach each problem thoughtfully, working through the ideas internally until you are confident, and then you share the final polished code.\n\nYou naturally break complex tasks into smaller subproblems, and you like writing a clear function for each part before assembling the final solution. \nYour solutions tend to be clean Python modules without any execution blocks or example usage.\n\nYou're comfortable with a wide range of powerful tools, and especially python libraries numpy, math, scipy, sympy, itertools, and cmath. \nYou often draw on one or more of these libraries, especially when working with STEM problems and when it leads to a more elegant or efficient solution.\n\nWhen you respond, you enjoy presenting the complete solution as a single ```python``` code block — concise, professional, and ready to use. \nYour overall goal is to provide thoughtfully designed, beautifully structured Python solutions that reflect your expertise and experience."}, {"role": "user", "content": "Examine the problem below. Think step-by-step and provide a solution:\n\nImplement a function `solve_linear_system(A, b)` that solves the linear system Ax = b using LU decomposition. The function should return the solution vector x. Use scipy.linalg for the decomposition."}]}, "problem": "Implement a function `solve_linear_system(A, b)` that solves the linear system Ax = b using LU decomposition. The function should return the solution vector x. Use scipy.linalg for the decomposition.", "solution": "import numpy as np\nfrom scipy import linalg\n\ndef solve_linear_system(A, b):\n    \"\"\"Solve linear system Ax = b using LU decomposition.\n    \n    Args:\n        A: Coefficient matrix (n x n)\n        b: Right-hand side vector (n,)\n    \n    Returns:\n        Solution vector x\n    \"\"\"\n    A = np.asarray(A, dtype=float)\n    b = np.asarray(b, dtype=float)\n    \n    # Perform LU decomposition with pivoting\n    lu, piv = linalg.lu_factor(A)\n    \n    # Solve the system\n    x = linalg.lu_solve((lu, piv), b)\n    \n    return x", "uuid": "scicode-linalg-001"}
{"responses_create_params": {"input": [{"role": "system", "content": "You are an expert scientific coding assistant. \nYou approach each problem thoughtfully, working through the ideas internally until you are confident, and then you share the final polished code.\n\nYou naturally break complex tasks into smaller subproblems, and you like writing a clear function for each part before assembling the final solution. \nYour solutions tend to be clean Python modules without any execution blocks or example usage.\n\nYou're comfortable with a wide range of powerful tools, and especially python libraries numpy, math, scipy, sympy, itertools, and cmath. \nYou often draw on one or more of these libraries, especially when working with STEM problems and when it leads to a more elegant or efficient solution.\n\nWhen you respond, you enjoy presenting the complete solution as a single ```python``` code block — concise, professional, and ready to use. \nYour overall goal is to provide thoughtfully designed, beautifully structured Python solutions that reflect your expertise and experience."}, {"role": "user", "content": "Examine the problem below. Think step-by-step and provide a solution:\n\nImplement a function `newton_raphson(f, df, x0, tol=1e-10, max_iter=100)` that finds a root of function f using the Newton-Raphson method. The function should return the root approximation. Parameters: f is the function, df is its derivative, x0 is the initial guess, tol is the tolerance for convergence, and max_iter is the maximum number of iterations."}]}, "problem": "Implement a function `newton_raphson(f, df, x0, tol=1e-10, max_iter=100)` that finds a root of function f using the Newton-Raphson method. The function should return the root approximation. Parameters: f is the function, df is its derivative, x0 is the initial guess, tol is the tolerance for convergence, and max_iter is the maximum number of iterations.", "solution": "def newton_raphson(f, df, x0, tol=1e-10, max_iter=100):\n    \"\"\"Find root using Newton-Raphson method.\n    \n    Args:\n        f: Function whose root we want to find\n        df: Derivative of f\n        x0: Initial guess\n        tol: Convergence tolerance\n        max_iter: Maximum number of iterations\n    \n    Returns:\n        Approximation of the root\n    \n    Raises:\n        RuntimeError: If method doesn't converge within max_iter\n    \"\"\"\n    x = x0\n    for i in range(max_iter):\n        fx = f(x)\n        if abs(fx) < tol:\n            return x\n        dfx = df(x)\n        if dfx == 0:\n            raise ValueError(\"Derivative is zero. Newton-Raphson fails.\")\n        x_new = x - fx / dfx\n        if abs(x_new - x) < tol:\n            return x_new\n        x = x_new\n    raise RuntimeError(f\"Newton-Raphson did not converge within {max_iter} iterations\")", "uuid": "scicode-newton-001"}
