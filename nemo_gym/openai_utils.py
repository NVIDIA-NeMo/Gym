from typing import (
    Dict,
    List,
    Union,
    Required,
    Literal,
    Optional,
    TypeAlias,
)

from pydantic import BaseModel, ConfigDict, Field

from openai import AsyncOpenAI
from openai.types.responses import (
    ResponseOutputMessage,
    ResponseFunctionToolCall,
    ResponseOutputText,
    ResponseOutputTextParam,
    ResponseInputTextParam,
    ResponseFunctionToolCallParam,
    FunctionToolParam,
    ResponseOutputRefusalParam,
)
from openai.types.responses.response_output_text_param import Annotation, Logprob
from openai.types.responses.response_create_params import (
    ToolParam,
    ResponseIncludable,
    Metadata,
    ResponsesModel,
    ResponsePromptParam,
    Reasoning,
    ResponseTextConfigParam,
    ToolChoice,
)
from openai.types.responses.response_input_param import (
    ResponseInputMessageContentListParam,
)
from openai.types.responses.response_reasoning_item import (
    Summary,
    ResponseReasoningItem,
)
from openai.types.shared.chat_model import ChatModel
from openai.types.chat.completion_create_params import (
    ChatCompletionAudioParam,
    ChatCompletionPredictionContentParam,
    ReasoningEffort,
    ResponseFormat,
    ChatCompletionStreamOptionsParam,
    ChatCompletionToolChoiceOptionParam,
    WebSearchOptions,
)
from openai.types.chat.chat_completion_message import FunctionCall
from openai.types.chat import (
    ChatCompletion,
    ChatCompletionToolParam,
    ChatCompletionMessage,
    ChatCompletionUserMessageParam,
    ChatCompletionSystemMessageParam,
    ChatCompletionDeveloperMessageParam,
    ChatCompletionAssistantMessageParam,
    ChatCompletionMessageToolCallParam,
    ChatCompletionMessageToolCall,
    ChatCompletionContentPartTextParam,
    ChatCompletionToolMessageParam,
)
from openai.types.chat.chat_completion_assistant_message_param import (
    ContentArrayOfContentPart,
)
from openai.types.chat.completion_create_params import Function
from openai.types.chat.chat_completion import Choice
from openai.types.responses import (
    Response,
    ResponseOutputItem,
)

from openai.types.shared_params import FunctionDefinition

from nemo_gym.server_utils import GLOBAL_HTTPX_CLIENT


class NeMoGymSummary(Summary):
    pass


class NeMoGymResponseReasoningItemParam(BaseModel):
    id: str
    # Override the Iterable to avoid lazy iterators in Pydantic validation.
    summary: List[NeMoGymSummary]
    type: Literal["reasoning"]
    encrypted_content: str = None
    status: Literal["in_progress", "completed", "incomplete"]


class NeMoGymResponseReasoningItem(ResponseReasoningItem):
    pass


class NeMoGymResponseOutputTextParam(BaseModel):
    # Override the Iterable to avoid lazy iterators in Pydantic validation.
    annotations: List[Annotation]
    text: str
    type: Literal["output_text"]
    logprobs: Optional[List[Logprob]] = None


NeMoGymContent: TypeAlias = Union[
    NeMoGymResponseOutputTextParam, ResponseOutputRefusalParam
]


class NeMoGymResponseOutputMessageParam(BaseModel):
    id: str
    # Override the Iterable to avoid lazy iterators in Pydantic validation.
    content: List[NeMoGymContent]
    role: Literal["assistant"]
    status: Literal["in_progress", "completed", "incomplete"]
    type: Literal["message"]


class NeMoGymEasyInputMessageParam(BaseModel):
    content: Union[str, ResponseInputMessageContentListParam]
    role: Literal["user", "assistant", "system", "developer"]
    type: Literal["message"] = "message"


class NeMoGymMessage(BaseModel):
    content: ResponseInputMessageContentListParam
    role: Literal["user", "system", "developer"]
    status: Literal["in_progress", "completed", "incomplete"] = "completed"
    type: Literal["message"] = "message"


class NeMoGymFunctionCallOutput(BaseModel):
    """
    We copy openai.types.responses.response_input_param.FunctionCallOutput, originally a TypedDict, as a BaseModel here
    so that we can use it in the NeMoGymResponseOutputItem below and be consistent with the other ResponseOutputItem types.
    """

    call_id: str
    """The unique ID of the function tool call generated by the model."""

    output: str
    """A JSON string of the output of the function tool call."""

    type: Literal["function_call_output"]
    """The type of the function tool call output. Always `function_call_output`."""

    id: Optional[str] = None
    """The unique ID of the function tool call output.

    Populated when this item is returned via API.
    """

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None
    """The status of the item.

    One of `in_progress`, `completed`, or `incomplete`. Populated when items are
    returned via API.
    """


class NeMoGymResponseFunctionToolCallParam(ResponseFunctionToolCallParam):
    pass


NeMoGymResponseInputItemParam = Union[
    NeMoGymEasyInputMessageParam,
    NeMoGymMessage,
    NeMoGymResponseOutputMessageParam,
    NeMoGymResponseFunctionToolCallParam,
    NeMoGymFunctionCallOutput,
    NeMoGymResponseReasoningItemParam,
]
NeMoGymResponseInputParam: TypeAlias = List[NeMoGymResponseInputItemParam]


class NeMoGymResponseCreateParamsNonStreaming(BaseModel):
    """
    This class is a copy of openai.types.responses.response_create_params.ResponseCreateParamsNonStreaming
    We make a copy of it here since ResponseCreateParamsNonStreaming is a TypedDict with no strict validation.
    We need to do server side validation here.
    """

    model_config = ConfigDict(extra="forbid")

    background: Optional[bool] = None
    include: Optional[List[ResponseIncludable]] = None
    input: Union[str, NeMoGymResponseInputParam]
    instructions: Optional[str] = None
    max_output_tokens: Optional[int] = None
    max_tool_calls: Optional[int] = None
    metadata: Optional[Metadata] = None
    model: Optional[ResponsesModel] = None
    parallel_tool_calls: Optional[bool] = None
    previous_response_id: Optional[str] = None
    prompt: Optional[ResponsePromptParam] = None
    reasoning: Optional[Reasoning] = None
    service_tier: Optional[Literal["auto", "default", "flex", "scale", "priority"]] = (
        None
    )
    store: Optional[bool] = None
    temperature: Optional[float] = None
    text: Optional[ResponseTextConfigParam] = None
    tool_choice: Optional[ToolChoice] = None
    # Override the Iterable to avoid lazy iterators in Pydantic validation.
    tools: List[ToolParam] = Field(default_factory=list)
    top_logprobs: Optional[int] = None
    top_p: Optional[float] = None
    truncation: Optional[Literal["auto", "disabled"]] = None
    user: str = ""
    stream: Optional[Literal[False]] = None


NeMoGymResponseOutputItem = Union[
    NeMoGymMessage, NeMoGymFunctionCallOutput, ResponseOutputItem
]


class NeMoGymResponse(Response):
    output: List[NeMoGymResponseOutputItem]


class NeMoGymResponseOutputMessage(ResponseOutputMessage):
    pass


class NeMoGymResponseFunctionToolCall(ResponseFunctionToolCall):
    name: str
    arguments: str
    call_id: str


class NeMoGymResponseOutputText(ResponseOutputText):
    pass


class NeMoGymResponseOutputTextParam(ResponseOutputTextParam):
    pass


class NeMoGymResponseInputTextParam(ResponseInputTextParam):
    pass


class NeMoGymFunctionDefinition(FunctionDefinition):
    pass


class NeMoGymChatCompletionToolParam(ChatCompletionToolParam):
    function: Required[NeMoGymFunctionDefinition]


class NeMoGymFunctionCall(FunctionCall):
    pass


class NeMoGymChatCompletionMessage(ChatCompletionMessage):
    pass


class NeMoGymChatCompletion(ChatCompletion):
    pass


class NeMoGymChatCompletionContentPartTextParam(ChatCompletionContentPartTextParam):
    pass


class NeMoGymChatCompletionUserMessageParam(ChatCompletionUserMessageParam):
    # Override the iterable which is annoying to work with.
    content: Required[Union[str, List[NeMoGymChatCompletionContentPartTextParam]]]


class NeMoGymChatCompletionSystemMessageParam(ChatCompletionSystemMessageParam):
    # Override the iterable which is annoying to work with.
    content: Required[Union[str, List[NeMoGymChatCompletionContentPartTextParam]]]


class NeMoGymChatCompletionDeveloperMessageParam(ChatCompletionDeveloperMessageParam):
    # Override the iterable which is annoying to work with.
    content: Required[Union[str, List[NeMoGymChatCompletionContentPartTextParam]]]


class NeMoGymChatCompletionMessageToolCallParam(ChatCompletionMessageToolCallParam):
    pass


class NeMoGymChatCompletionAssistantMessageParam(ChatCompletionAssistantMessageParam):
    # Override the iterable which is annoying to work with.
    content: Union[str, List[ContentArrayOfContentPart], None]
    tool_calls: List[NeMoGymChatCompletionMessageToolCallParam]


class NeMoGymChatCompletionMessageToolCall(ChatCompletionMessageToolCall):
    pass


class NeMoGymChatCompletionToolMessageParam(ChatCompletionToolMessageParam):
    # Override the iterable which is annoying to work with.
    content: Required[Union[str, List[NeMoGymChatCompletionContentPartTextParam]]]


class NeMoGymChoice(Choice):
    pass


class NeMoGymFunction(Function):
    pass


class NeMoGymFunctionToolParam(FunctionToolParam):
    pass


NeMoGymChatCompletionMessageParam: TypeAlias = Union[
    NeMoGymChatCompletionDeveloperMessageParam,
    NeMoGymChatCompletionSystemMessageParam,
    NeMoGymChatCompletionUserMessageParam,
    NeMoGymChatCompletionAssistantMessageParam,
    NeMoGymChatCompletionToolMessageParam,
    # Don't add deprecated.
    # NeMoGymChatCompletionFunctionMessageParam,
]


class NeMoGymChatCompletionCreateParamsNonStreaming(BaseModel):
    messages: List[NeMoGymChatCompletionMessageParam]
    model: Optional[Union[str, ChatModel]] = None
    audio: Optional[ChatCompletionAudioParam] = None
    frequency_penalty: Optional[float] = None
    logit_bias: Optional[Dict[str, int]] = None
    logprobs: Optional[bool] = None
    max_completion_tokens: Optional[int] = None
    max_tokens: Optional[int] = None
    metadata: Optional[Metadata] = None
    modalities: Optional[List[Literal["text", "audio"]]] = None
    n: Optional[int] = None
    parallel_tool_calls: bool = True
    prediction: Optional[ChatCompletionPredictionContentParam] = None
    presence_penalty: Optional[float] = None
    reasoning_effort: Optional[ReasoningEffort] = None
    response_format: Optional[ResponseFormat] = None
    seed: Optional[int] = None
    service_tier: Optional[Literal["auto", "default", "flex", "scale", "priority"]] = (
        None
    )
    stop: Union[Optional[str], List[str], None] = None
    store: Optional[bool] = None
    stream_options: Optional[ChatCompletionStreamOptionsParam] = None
    temperature: Optional[float] = None
    tool_choice: Optional[ChatCompletionToolChoiceOptionParam] = None
    tools: Optional[List[NeMoGymChatCompletionToolParam]] = None
    top_logprobs: Optional[int] = None
    top_p: Optional[float] = None
    user: str = ""
    web_search_options: Optional[WebSearchOptions] = None
    stream: Optional[Literal[False]] = None

    # Disallow deprecated args
    # function_call: FunctionCall
    # functions: Iterable[Function]


class NeMoGymAsyncOpenAI(AsyncOpenAI):
    def __init__(self, **kwargs) -> None:
        # TODO: this setup is take from https://github.com/NVIDIA/NeMo-Skills/blob/80dc78ac758c4cac81c83a43a729e7ca1280857b/nemo_skills/inference/model/base.py#L318
        # However, there may still be a lingering issue regarding saturating at 100 max connections
        kwargs["http_client"] = GLOBAL_HTTPX_CLIENT
        kwargs["timeout"] = None  # Enforce no timeout

        super().__init__(**kwargs)
